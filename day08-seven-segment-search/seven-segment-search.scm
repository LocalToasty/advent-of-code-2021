(import (scheme base)
        (scheme comparator)
        (scheme file)
        (scheme hash-table)
        (scheme list)
        (scheme process-context)
        (scheme read)
        (scheme regex)
        (scheme sort)
        (scheme write))

(define (read-input filename)
  (with-input-from-file filename
    (lambda ()
      (unfold eof-object?
              parse-datapoint
              (lambda (x) (read-line))
              (read-line)))))

(define (parse-datapoint line)
  (let* ((segments (regexp-extract '(+ (/ "ag")) line))
         (segment-chars (map (lambda (s) (list-sort char<? (string->list s))) segments))
         (segment-symbols (map (lambda (digit)
                                 (map (lambda (c) (string->symbol (string c)))
                                      digit))
                               segment-chars)))
    (call-with-values (lambda () (split-at segment-symbols 10))
                      cons)))

(define (part1 inputs)
  (let ((unique-count? (lambda (segments) (case (length segments)
                                     ((2 3 4 7) #t)
                                     (else #f)))))
    (fold (lambda (line sum)
            (+ sum
               (count unique-count? (cdr line))))
            0
            inputs)))

(define (part2 inputs)
  (fold + 0 (map decode-line inputs)))

(define (decode-line line)
  (let* ((decodings (get-decodings (car line)))
         (digits (map (lambda (segments) (hash-table-ref decodings segments))
                      (cdr line))))
    (fold (lambda (d n) (+ (* 10 n) d)) 0 digits)))

(define (get-decodings line)
  (let ((table (make-hash-table (make-default-comparator))))
    ; populate with unique values (1, 4, 7, 8)
    (for-each (lambda (segments)
                (case (length segments)
                  ((2) (hash-table-set! table 1 segments))
                  ((3) (hash-table-set! table 7 segments))
                  ((4) (hash-table-set! table 4 segments))
                  ((7) (hash-table-set! table 8 segments))))
              line)
    ; populate with 6-segment numbers (0, 6, 9)
    (for-each (lambda (segments)
                (if (= 6 (length segments))
                  (cond ((lset<= eq? (hash-table-ref table 4) segments)
                         (hash-table-set! table 9 segments))
                        ((lset<= eq? (hash-table-ref table 7) segments)
                         (hash-table-set! table 0 segments))
                        (else
                         (hash-table-set! table 6 segments)))))
              line)
    ; populate with 5-segment numbers (2, 3, 5)
    (for-each (lambda (segments)
                (if (= 5 (length segments))
                  (cond ((lset<= eq? (hash-table-ref table 7) segments)
                         (hash-table-set! table 3 segments))
                        ((lset<= eq? segments (hash-table-ref table 9))
                         (hash-table-set! table 5 segments))
                        (else
                         (hash-table-set! table 2 segments)))))
              line)
    (invert table)))

(define (invert table)
  (let ((res (make-hash-table (make-default-comparator))))
    (hash-table-for-each (lambda (k v) (hash-table-set! res v k)) table)
    res))

(define inputs (read-input (cadr (command-line))))
(write (part1 inputs)) (newline)
(write (part2 inputs)) (newline)
